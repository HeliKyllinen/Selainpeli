<!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palapeli</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 20px;
        }

        #puzzleContainer {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1px;
            position: relative;
            border: 2px solid #333;
            background-image: linear-gradient(to right, #333 1px, transparent 1px),
                linear-gradient(to bottom, #333 1px, transparent 1px);
            background-size: calc(100% / 4) calc(100% / 4);
            overflow: hidden;
        }

        .puzzlePiece {
            position: absolute;
            border: 1px solid #333;
            clip-path: url(#puzzle-piece-clip);
            /* Palojen muotoilu */
            cursor: pointer;
            width: 100px;
            height: 100px;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }

        #searchSection {
            margin-bottom: 20px;
        }

        #completedMessage {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            color: green;
        }
    </style>
</head>

<body>
    <h1>Palapeli</h1>
    <div id="searchSection">
        <input type="text" id="searchQuery" placeholder="Anna hakusana" />
        <button onclick="searchImage()">Hae kuva</button>
    </div>
    <div id="puzzleContainer"></div>
    <div id="completedMessage">Palapeli on valmis! Aikasi oli <span id="timeSpent"></span>.</div>

    <div id="clipPaths" style="position: absolute; width: 0; height: 0; overflow: hidden;"></div>
    <svg width="0" height="0">
        <defs>

            <clipPath id="puzzle-piece-clip-0-0">
                <path d="M0,0 h100 v20 q-10,10 0,20 v60 q10,10 0,20 h-100 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-0-1">
                <path d="M0,0 h20 q10,-10 20,0 h60 v100 h-80 q-10,-10 -20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-0-2">
                <path d="M0,0 h100 v20 q-10,10 0,20 v40 q10,10 0,20 h-100 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-0-3">
                <path d="M0,0 h80 q20,-10 20,10 v80 q-10,20 -20,10 h-80 Z" />
            </clipPath>

            <clipPath id="puzzle-piece-clip-1-0">
                <path d="M0,0 h20 q10,10 0,20 h80 v60 h-80 q-10,10 0,20 h-20 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-1-1">
                <path d="M20,0 h60 q10,20 20,10 v60 q-10,10 -20,10 h-60 q-10,-20 -20,-10 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-1-2">
                <path d="M0,0 h100 v100 h-20 q-10,10 -20,0 h-60 v-80 q10,-10 20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-1-3">
                <path d="M0,0 h100 v20 q10,10 0,20 v60 h-100 Z" />
            </clipPath>

            <clipPath id="puzzle-piece-clip-2-0">
                <path d="M0,0 h20 q10,-10 20,0 h60 v80 q-10,10 -20,0 h-60 q-10,10 -20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-2-1">
                <path d="M0,0 h80 v20 q10,10 0,20 h-80 q-10,10 -20,0 v-20 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-2-2">
                <path d="M0,0 h100 v20 q-10,10 0,20 v60 q10,10 0,20 h-100 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-2-3">
                <path d="M20,0 h60 q10,-10 20,10 v80 h-100 v-20 q10,-10 20,0 Z" />
            </clipPath>

            <clipPath id="puzzle-piece-clip-3-0">
                <path d="M0,0 h100 v100 h-20 q-10,10 -20,0 h-60 v-80 q10,-10 20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-3-1">
                <path d="M20,0 h60 q10,10 0,20 v80 h-100 v-60 q10,-10 20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-3-2">
                <path d="M0,0 h100 v20 q10,10 0,20 v60 h-80 q-10,-10 -20,0 Z" />
            </clipPath>
            <clipPath id="puzzle-piece-clip-3-3">
                <path d="M0,0 h100 v100 h-100 Z" />
            </clipPath>
        </defs>
    </svg>
    </div>

    <script>
        let img = new Image();
        let selectedPiece = null;
        let offsetX, offsetY;
        let startTime = null;
        let timerRunning = false;

        // Kuva haetaan backendistä
        async function searchImage() {
            const query = document.getElementById('searchQuery').value.trim();
            if (query === '') {
                alert('Syötä hakusana');
                return;
            }

            try {
                const response = await fetch(`/searchImage?query=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.imageUrl) {
                    img.src = data.imageUrl;

                    img.onload = () => {
                        //Kuva näytetään ensin oikean kokoisena eikä enää 400px x 400px
                        const puzzleContainer = document.getElementById('puzzleContainer');
                        puzzleContainer.style.width = img.width + 'px';
                        puzzleContainer.style.height = img.height + 'px';

                        // Näyttää ensin kokonaisen kuvan
                        showImageFirst(data.imageUrl);
                    };
                } else {
                    alert(data.error || 'Kuvaa ei löytynyt!');
                }
            } catch (error) {
                console.error('Virhe haettaessa kuvia:', error);
                alert('Virhe haettaessa kuvia.');
            }
        }

        // Näyttää kuvan kokonaisena 3 sekuntia ennen palapelin luomista
        function showImageFirst(imageUrl) {
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = ''; // Tyhjentää mahdolliset aiemmat palapelit

            // Poistaa ruudukon, kun kuva näytetään kokonaisena ennen palapelin luomista
            puzzleContainer.style.display = 'block'; // Näyttää kuvan kokonaisena eikä yhdessä pienessä ruudussa
            puzzleContainer.style.backgroundImage = 'none'; // Poistaa ruudukon

            // Luo kuvaelementin, joka näyttää koko kuvan
            const fullImage = document.createElement('img');
            fullImage.src = imageUrl;
            fullImage.style.width = '100%';
            fullImage.style.height = '100%';
            fullImage.style.objectFit = 'cover';

            puzzleContainer.appendChild(fullImage);

            // 3 sekuntia ja muodosta palapeli
            setTimeout(() => {
                puzzleContainer.removeChild(fullImage); // Poista kokonainen kuva

                // Ruudukko näkyviin
                puzzleContainer.style.display = 'grid';
                puzzleContainer.style.backgroundImage =
                    'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
                puzzleContainer.style.backgroundSize = 'calc(100% / 4) calc(100% / 4)';

                createPuzzle(imageUrl); // Luo palapeli kuvan perusteella
            }, 3000); // 3 sekunnin viive
        }

        // Hiiren painikkeen painamisen käsittely
        function onMouseDown(e) {
            selectedPiece = e.target;
            offsetX = e.clientX - selectedPiece.getBoundingClientRect().left;
            offsetY = e.clientY - selectedPiece.getBoundingClientRect().top;

            // Ajastin käyntiin
            if (!timerRunning) {
                startTimer();
                timerRunning = true;
            }
        }

        // Hiiren liikuttamisen käsittely
        function onMouseMove(e) {
            if (selectedPiece) {
                const container = document.getElementById('puzzleContainer');
                const containerRect = container.getBoundingClientRect();

                let newLeft = e.clientX - offsetX - containerRect.left;
                let newTop = e.clientY - offsetY - containerRect.top;

                // Estää palan liikkuminen kontin rajojen yli
                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft + selectedPiece.offsetWidth > container.offsetWidth) {
                    newLeft = container.offsetWidth - selectedPiece.offsetWidth;
                }
                if (newTop + selectedPiece.offsetHeight > container.offsetHeight) {
                    newTop = container.offsetHeight - selectedPiece.offsetHeight;
                }

                selectedPiece.style.left = newLeft + 'px';
                selectedPiece.style.top = newTop + 'px';
            }
        }

        // Hiiren painikkeen vapautuksen käsittely
        function onMouseUp() {
            if (selectedPiece) {
                const targetLeft = parseFloat(selectedPiece.style.left);
                const targetTop = parseFloat(selectedPiece.style.top);
                const correctLeft = parseFloat(selectedPiece.dataset.correctLeft);
                const correctTop = parseFloat(selectedPiece.dataset.correctTop);

                // Tarkista, onko pala oikeassa paikassa
                if (Math.abs(targetLeft - correctLeft) < 10 && Math.abs(targetTop - correctTop) < 10) {
                    selectedPiece.style.left = correctLeft + 'px';
                    selectedPiece.style.top = correctTop + 'px';
                    selectedPiece.style.pointerEvents = 'none'; // Pala ei ole enää siirrettävissä
                    selectedPiece.style.zIndex = 0; // Jos pala on oikeassa paikassa, niin se jää väärän palan alle
                } else {
                    // Palaa alkuperäiseen sijaintiin
                    selectedPiece.style.left = selectedPiece.dataset.originalLeft;
                    selectedPiece.style.top = selectedPiece.dataset.originalTop;
                }

                selectedPiece = null;

                // Onko peli valmis?
                checkIfPuzzleCompleted();
            }
        }

        // Palapelin luonti
        function createPuzzle(imageUrl) {
            const rows = 4;
            const cols = 4;
            const pieceMargin = 1;
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = ''; // Tyhjennys

            const pieceWidth = (img.width - (cols - 1) * pieceMargin) / cols;
            const pieceHeight = (img.height - (rows - 1) * pieceMargin) / rows;

            // Containerin koko riippuu nyt kuvan koosta
            puzzleContainer.style.width = img.width + 'px';
            puzzleContainer.style.height = img.height + 'px';

            const pieces = [];

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzlePiece';
                    piece.style.width = pieceWidth + 'px';
                    piece.style.height = pieceHeight + 'px';
                    piece.style.backgroundImage = `url(${imageUrl})`;
                    piece.style.backgroundPosition = `-${col * (pieceWidth + pieceMargin)}px -${row * (pieceHeight + pieceMargin)}px`;
                    piece.style.clipPath = `url(#puzzle-piece-clip-${row}-${col})`;

                    // Aseta palasten alkuperäinen sijainti satunnaisesti ruudukon ulkopuolelle
                    let randomX = Math.random() * (puzzleContainer.offsetWidth + 100) - 150;
                    let randomY = Math.random() * (puzzleContainer.offsetHeight + 100) - 150;

                    // Estää palan sijoittaminen näkyviin ruudukon sisälle
                    if (randomX < 0) randomX = -100;
                    if (randomX > puzzleContainer.offsetWidth) randomX = puzzleContainer.offsetWidth;
                    if (randomY < 0) randomY = -100;
                    if (randomY > puzzleContainer.offsetHeight) randomY = puzzleContainer.offsetHeight;

                    piece.style.left = randomX + 'px';
                    piece.style.top = randomY + 'px';
                    piece.style.zIndex = 2; // Varmistaa, että väärä pala jää näkyviin

                    // Tallentaa oikeat palat
                    piece.dataset.correctLeft = (col * (pieceWidth + pieceMargin)).toString();
                    piece.dataset.correctTop = (row * (pieceHeight + pieceMargin)).toString();
                    piece.dataset.originalLeft = piece.style.left;
                    piece.dataset.originalTop = piece.style.top;

                    piece.addEventListener('mousedown', onMouseDown);
                    pieces.push(piece);
                    puzzleContainer.appendChild(piece);
                }
            }

            // Nollaa ajastimen ja näyttää viestin
            resetTimer();
            document.getElementById('completedMessage').style.display = 'none';
        }

        // Palapelin valmistumisen tsekkaus
        function checkIfPuzzleCompleted() {
            const pieces = document.querySelectorAll('.puzzlePiece');
            let isCompleted = true;

            // Tarkastaa jokaisen palan sijainnin
            pieces.forEach(piece => {
                const left = parseInt(piece.style.left);
                const top = parseInt(piece.style.top);
                const correctLeft = parseInt(piece.dataset.correctLeft);
                const correctTop = parseInt(piece.dataset.correctTop);

                if (left !== correctLeft || top !== correctTop) {
                    isCompleted = false;
                }
            });

            // Ajastimen pysäytys, jos kaikki palaset ovat oikeilla paikoillaan
            if (isCompleted) {
                stopTimer();
            }
        }

        // Ajastin käyntiin
        function startTimer() {
            startTime = new Date();
        }

        // Ajastin pois päältä
        function stopTimer() {
            const endTime = new Date();
            const timeSpent = Math.round((endTime - startTime) / 1000);
            document.getElementById('timeSpent').textContent = `${timeSpent} sekuntia`;
            document.getElementById('completedMessage').style.display = 'block';
        }

        // Nollaa ajastin
        function resetTimer() {
            startTime = null;
            timerRunning = false;
            document.getElementById('completedMessage').style.display = 'none';
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    </script>
</body>

</html>

<!-- <!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palapeli</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 20px;
        }

        #puzzleContainer {
            position: relative;
            width: 400px;
            height: 400px;
            border: 1px solid #333;
            overflow: visible;
        }

        .puzzlePiece {
            position: absolute;
            border: 1px solid #333;
            cursor: pointer;
        }

        #searchSection {
            margin-bottom: 20px;
        }

        #completedMessage {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            color: green;
        }
    </style>
</head>

<body>
    <h1>Palapeli</h1>
    <div id="searchSection">
        <input type="text" id="searchQuery" placeholder="Anna hakusana" />
        <button onclick="searchImage()">Hae kuva</button>
    </div>
    <div id="puzzleContainer"></div>
    <div id="completedMessage">Palapeli on valmis! Aikasi oli <span id="timeSpent"></span>.</div>

    <script>
        let img = new Image();
        let selectedPiece = null;
        let offsetX, offsetY;
        let startTime = null;
        let timerRunning = false;

        // Kuva haetaan backendistä
        async function searchImage() {
            const query = document.getElementById('searchQuery').value.trim();
            if (query === '') {
                alert('Syötä hakusana');
                return;
            }

            try {
                const response = await fetch(`/searchImage?query=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.imageUrl) {
                    img.src = data.imageUrl;
                    img.onload = function () {
                        createPuzzle(data.imageUrl);
                    };
                } else {
                    alert(data.error || 'Kuvaa ei löytynyt!');
                }
            } catch (error) {
                console.error('Virhe haettaessa kuvia:', error);
                alert('Virhe haettaessa kuvia.');
            }
        }

        // Hiiren painikkeen painamisen käsittely

        function onMouseDown(e) {
            // Ajastin käyntiin
            if (!timerRunning) {
                startTimer();
                timerRunning = true;
            }

            selectedPiece = e.target;
            offsetX = e.clientX - selectedPiece.getBoundingClientRect().left;
            offsetY = e.clientY - selectedPiece.getBoundingClientRect().top;
        }

        // Hiiren liikuttamisen käsittely
        function onMouseMove(e) {
            if (selectedPiece) {
                let newLeft = e.clientX - offsetX;
                let newTop = e.clientY - offsetY;
                const container = document.getElementById('puzzleContainer');
                const containerRect = container.getBoundingClientRect();
                const pieceWidth = selectedPiece.offsetWidth;
                const pieceHeight = selectedPiece.offsetHeight;

                // Palaset eivät voi poistua kontista, jotta ne eivät katoa (muuta myöhemmin niin, että palaset voi "laskea" kontin ulkopuolelle)
                if (newLeft < containerRect.left) newLeft = containerRect.left;
                if (newTop < containerRect.top) newTop = containerRect.top;
                if (newLeft + pieceWidth > containerRect.right) newLeft = containerRect.right - pieceWidth;
                if (newTop + pieceHeight > containerRect.bottom) newTop = containerRect.bottom - pieceHeight;

                selectedPiece.style.left = newLeft - containerRect.left + 'px';
                selectedPiece.style.top = newTop - containerRect.top + 'px';
            }
        }

        // Hiiren painikkeen vapautuksen käsittely
        function onMouseUp() {
            if (selectedPiece) {
                const targetLeft = parseFloat(selectedPiece.style.left);
                const targetTop = parseFloat(selectedPiece.style.top);
                const correctLeft = parseFloat(selectedPiece.dataset.correctLeft);
                const correctTop = parseFloat(selectedPiece.dataset.correctTop);

                // Tarkista, onko pala liikutettu merkittävästi
                const originalLeft = parseFloat(selectedPiece.dataset.originalLeft);
                const originalTop = parseFloat(selectedPiece.dataset.originalTop);
                const movedEnough = Math.abs(targetLeft - originalLeft) > 10 || Math.abs(targetTop - originalTop) > 10;

                // Palaset saavat vain lukittua oikeisiin paikkoihin
                if (movedEnough) {
                    // Onko pala oikeassa paikassa?
                    if (Math.abs(targetLeft - correctLeft) < 10 && Math.abs(targetTop - correctTop) < 10) {
                        // Siirrä pala oikeaan paikkaan
                        selectedPiece.style.left = correctLeft + 'px';
                        selectedPiece.style.top = correctTop + 'px';
                        selectedPiece.style.pointerEvents = 'none'; // Pala ei ole enää siirrettävissä
                    } else {
                        // Jos ei ole oikeassa paikassa, palaa alkuperäiseen sijaintiin
                        selectedPiece.style.left = originalLeft + 'px';
                        selectedPiece.style.top = originalTop + 'px';
                    }
                } else {
                    // Palaa alkuperäiseen sijaintiin, jos ei liikutettu tarpeeksi
                    selectedPiece.style.left = originalLeft + 'px';
                    selectedPiece.style.top = originalTop + 'px';
                }

                selectedPiece = null;

                // Onko peli valmis?
                checkIfPuzzleCompleted();
            }
        }

        function movePieceToRandomPosition(blockingPiece, allPieces) {
            const container = document.getElementById('puzzleContainer');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            let randomLeft, randomTop;
            let isFree = false;

            // Etsii satunnaisen vapaan paikan
            while (!isFree) {
                randomLeft = Math.floor(Math.random() * (containerWidth - blockingPiece.offsetWidth));
                randomTop = Math.floor(Math.random() * (containerHeight - blockingPiece.offsetHeight));

                isFree = true;

                // Onko paikka jo käytössä?
                allPieces.forEach(piece => {
                    const pieceLeft = parseFloat(piece.style.left);
                    const pieceTop = parseFloat(piece.style.top);

                    if (Math.abs(pieceLeft - randomLeft) < blockingPiece.offsetWidth && Math.abs(pieceTop - randomTop) < blockingPiece.offsetHeight) {
                        isFree = false;
                    }
                });
            }

            // Siirtää väärän palan uuteen ruutuun ja nostaa sen z-indexiä
            blockingPiece.style.left = randomLeft + 'px';
            blockingPiece.style.top = randomTop + 'px';
            blockingPiece.style.zIndex = ++highestZIndex; // Nostaa väärän palan päällimmäiseksi
        }

        // Sekoitetaan palat
        function shufflePieces(pieces) {
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i].style.left, pieces[j].style.left] = [pieces[j].style.left, pieces[i].style.left];
                [pieces[i].style.top, pieces[j].style.top] = [pieces[j].style.top, pieces[i].style.top];
            }
        }

        // Palapelin luonti
        function createPuzzle(imageUrl) {
            const rows = 4;
            const cols = 4;
            const pieceMargin = 5;
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = '';
            const pieceWidth = (img.width - (cols - 1) * pieceMargin) / cols;
            const pieceHeight = (img.height - (rows - 1) * pieceMargin) / rows;
            const pieces = [];

            // Kontti kuvan mittoihin
            puzzleContainer.style.width = img.width + 'px';
            puzzleContainer.style.height = img.height + 'px';

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzlePiece';
                    piece.style.width = pieceWidth + 'px';
                    piece.style.height = pieceHeight + 'px';
                    piece.style.backgroundImage = `url(${imageUrl})`;
                    piece.style.backgroundPosition = `-${col * (pieceWidth + pieceMargin)}px -${row * (pieceHeight + pieceMargin)}px`;

                    // Aseta palasten alkuperäinen sijainti satunnaisesti ruudukon ulkopuolelle
                    let randomX = Math.random() * (puzzleContainer.offsetWidth + 100) - 150; // 150px ruudukon vasemmalle ja oikealle
                    let randomY = Math.random() * (puzzleContainer.offsetHeight + 100) - 150; // 150px ruudukon ylös ja alas

                    // Estä palan sijoittaminen näkyviin ruudukon sisälle
                    if (randomX < 0) randomX = -pieceWidth; // Aseta vasemmalle
                    if (randomX > puzzleContainer.offsetWidth) randomX = puzzleContainer.offsetWidth; // Aseta oikealle
                    if (randomY < 0) randomY = -pieceHeight; // Aseta ylös
                    if (randomY > puzzleContainer.offsetHeight) randomY = puzzleContainer.offsetHeight; // Aseta alas

                    piece.style.left = randomX + 'px';
                    piece.style.top = randomY + 'px';

                    // Tallennetaan oikeat paikat
                    piece.dataset.correctLeft = (col * (pieceWidth + pieceMargin)).toString();
                    piece.dataset.correctTop = (row * (pieceHeight + pieceMargin)).toString();
                    piece.dataset.originalLeft = piece.style.left;
                    piece.dataset.originalTop = piece.style.top;

                    piece.addEventListener('mousedown', onMouseDown);
                    pieces.push(piece);
                    puzzleContainer.appendChild(piece);
                }
            }

            // Sekoitetaan palaset
            shufflePieces(pieces);

            // Nollataan ajastin ja näytetään viesti
            resetTimer();
            document.getElementById('completedMessage').style.display = 'none';
        }


        // Palapelin valmistumisen tsekkaus
        function checkIfPuzzleCompleted() {
            const pieces = document.querySelectorAll('.puzzlePiece');
            let isCompleted = true;

            // Tarkistetaan jokaisen palan sijainti
            pieces.forEach(piece => {
                const left = parseInt(piece.style.left);
                const top = parseInt(piece.style.top);
                const correctLeft = parseInt(piece.dataset.correctLeft);
                const correctTop = parseInt(piece.dataset.correctTop);

                if (left !== correctLeft || top !== correctTop) {
                    isCompleted = false;
                }
            });

            // Ajastimen pysäytys, jos kaikki palaset ovat oikeilla paikoillaan
            if (isCompleted) {
                stopTimer();
            }
        }

        // Ajastin käyntiin
        function startTimer() {
            startTime = new Date();
        }

        // Ajastin pois päältä (muunnos sekunneiksi)
        function stopTimer() {
            const endTime = new Date();
            const timeSpent = (endTime - startTime) / 1000;
            document.getElementById('timeSpent').innerText = `${timeSpent.toFixed(2)} sekuntia`;
            document.getElementById('completedMessage').style.display = 'block';
        }

        // Ajastimen resetointi
        function resetTimer() {
            startTime = null;
            timerRunning = false;
            document.getElementById('completedMessage').style.display = 'none'; // Piilota valmis-viesti
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);

    </script>
</body>

</html> -->