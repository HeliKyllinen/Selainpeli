<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palapeli</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 20px;
        }

        #puzzleContainer {
            display: grid;
            gap: 1px;
            position: relative;
            border: 2px solid #333;
            background-image: linear-gradient(to right, #333 1px, transparent 1px),
                linear-gradient(to bottom, #333 1px, transparent 1px);
            overflow: hidden;
        }

        .puzzlePiece {
            position: absolute;
            border: 1px solid #333;
            cursor: pointer;
            z-index: 1;
        }

        #searchSection {
            margin-bottom: 20px;
        }

        #completedMessage {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            color: green;
        }
    </style>
</head>

<body>
    <h1>Palapeli</h1>
    <div id="searchSection">
        <input type="text" id="searchQuery" placeholder="Anna hakusana" />
        <button onclick="searchImage()">Hae kuva</button>
    </div>
    
    <label for="puzzleSize">Valitse palapelin koko:</label>
    <select id="puzzleSize" onchange="updatePuzzleSize()">
        <option value="5">5x5 (25 palaa)</option>
        <option value="6">6x6 (36 palaa)</option>
        <option value="7">7x7 (49 palaa)</option>
    </select>
    
    <div id="puzzleContainer"></div>
    <div id="completedMessage">Palapeli on valmis! Aikasi oli <span id="timeSpent"></span>.</div>

    <script>
        let img = new Image();
        let selectedPiece = null;
        let offsetX, offsetY;
        let startTime = null;
        let timerRunning = false;
        let selectedRows = 5; // oletuskoko 5x5
        let selectedCols = 5;

        async function searchImage() {
            const query = document.getElementById('searchQuery').value.trim();
            if (query === '') {
                alert('Syötä hakusana');
                return;
            }

            try {
                const response = await fetch(`/searchImage?query=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.imageUrl) {
                    img.src = data.imageUrl;

                    img.onload = () => {
                        const puzzleContainer = document.getElementById('puzzleContainer');
                        puzzleContainer.style.width = img.width + 'px';
                        puzzleContainer.style.height = img.height + 'px';

                        showImageFirst(data.imageUrl);
                    };
                } else {
                    alert(data.error || 'Kuvaa ei löytynyt!');
                }
            } catch (error) {
                console.error('Virhe haettaessa kuvia:', error);
                alert('Virhe haettaessa kuvia.');
            }
        }

        function showImageFirst(imageUrl) {
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = '';

            puzzleContainer.style.display = 'block';
            puzzleContainer.style.backgroundImage = 'none';

            const fullImage = document.createElement('img');
            fullImage.src = imageUrl;
            fullImage.style.width = '100%';
            fullImage.style.height = '100%';
            fullImage.style.objectFit = 'cover';

            puzzleContainer.appendChild(fullImage);

            setTimeout(() => {
                puzzleContainer.removeChild(fullImage);
                puzzleContainer.style.display = 'grid';
                puzzleContainer.style.backgroundImage =
                    'linear-gradient(to right, #333 1px, transparent 1px), linear-gradient(to bottom, #333 1px, transparent 1px)';
                puzzleContainer.style.backgroundSize = `calc(100% / ${selectedCols}) calc(100% / ${selectedRows})`;

                createPuzzle(imageUrl);
            }, 3000);
        }

        function onMouseDown(e) {
            selectedPiece = e.target;
            offsetX = e.clientX - selectedPiece.getBoundingClientRect().left;
            offsetY = e.clientY - selectedPiece.getBoundingClientRect().top;

            if (!timerRunning) {
                startTimer();
                timerRunning = true;
            }
        }

        function onMouseMove(e) {
            if (selectedPiece) {
                const container = document.getElementById('puzzleContainer');
                const containerRect = container.getBoundingClientRect();

                let newLeft = e.clientX - offsetX - containerRect.left;
                let newTop = e.clientY - offsetY - containerRect.top;

                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft + selectedPiece.offsetWidth > container.offsetWidth) {
                    newLeft = container.offsetWidth - selectedPiece.offsetWidth;
                }
                if (newTop + selectedPiece.offsetHeight > container.offsetHeight) {
                    newTop = container.offsetHeight - selectedPiece.offsetHeight;
                }

                selectedPiece.style.left = newLeft + 'px';
                selectedPiece.style.top = newTop + 'px';
            }
        }

        function onMouseUp() {
            if (selectedPiece) {
                const targetLeft = parseFloat(selectedPiece.style.left);
                const targetTop = parseFloat(selectedPiece.style.top);
                const correctLeft = parseFloat(selectedPiece.dataset.correctLeft);
                const correctTop = parseFloat(selectedPiece.dataset.correctTop);

                if (Math.abs(targetLeft - correctLeft) < 10 && Math.abs(targetTop - correctTop) < 10) {
                    selectedPiece.style.left = correctLeft + 'px';
                    selectedPiece.style.top = correctTop + 'px';
                    selectedPiece.style.pointerEvents = 'none';
                    selectedPiece.style.zIndex = 0;
                } else {
                    selectedPiece.style.left = selectedPiece.dataset.originalLeft;
                    selectedPiece.style.top = selectedPiece.dataset.originalTop;
                }

                selectedPiece = null;
                checkIfPuzzleCompleted();
            }
        }

        function createPuzzle(imageUrl) {
            const rows = selectedRows;
            const cols = selectedCols;
            const pieceMargin = 1;
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = '';

            const pieceWidth = (img.width - (cols - 1) * pieceMargin) / cols;
            const pieceHeight = (img.height - (rows - 1) * pieceMargin) / rows;

            puzzleContainer.style.width = img.width + 'px';
            puzzleContainer.style.height = img.height + 'px';

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzlePiece';
                    piece.style.width = pieceWidth + 'px';
                    piece.style.height = pieceHeight + 'px';
                    piece.style.backgroundImage = `url(${imageUrl})`;
                    piece.style.backgroundPosition = `-${col * (pieceWidth + pieceMargin)}px -${row * (pieceHeight + pieceMargin)}px`;

                    let randomX = Math.random() * (puzzleContainer.offsetWidth + 100) - 150;
                    let randomY = Math.random() * (puzzleContainer.offsetHeight + 100) - 150;

                    if (randomX < 0) randomX = -100;
                    if (randomX > puzzleContainer.offsetWidth) randomX = puzzleContainer.offsetWidth;
                    if (randomY < 0) randomY = -100;
                    if (randomY > puzzleContainer.offsetHeight) randomY = puzzleContainer.offsetHeight;

                    piece.style.left = randomX + 'px';
                    piece.style.top = randomY + 'px';
                    piece.style.zIndex = 2;

                    piece.dataset.correctLeft = (col * (pieceWidth + pieceMargin)).toString();
                    piece.dataset.correctTop = (row * (pieceHeight + pieceMargin)).toString();
                    piece.dataset.originalLeft = piece.style.left;
                    piece.dataset.originalTop = piece.style.top;

                    piece.addEventListener('mousedown', onMouseDown);
                    puzzleContainer.appendChild(piece);
                }
            }

            resetTimer();
            document.getElementById('completedMessage').style.display = 'none';
        }

        function updatePuzzleSize() {
            const size = parseInt(document.getElementById('puzzleSize').value, 10);
            selectedRows = size;
            selectedCols = size;
            createPuzzle(img.src);
        }

        function checkIfPuzzleCompleted() {
            const pieces = document.querySelectorAll('.puzzlePiece');
            let isCompleted = true;

            pieces.forEach(piece => {
                const left = parseInt(piece.style.left);
                const top = parseInt(piece.style.top);
                const correctLeft = parseInt(piece.dataset.correctLeft);
                const correctTop = parseInt(piece.dataset.correctTop);

                if (left !== correctLeft || top !== correctTop) {
                    isCompleted = false;
                }
            });

            if (isCompleted) {
                stopTimer();
                document.getElementById('completedMessage').style.display = 'block';
            }
        }

        function startTimer() {
            startTime = new Date();
        }

        function stopTimer() {
            if (startTime) {
                const timeSpent = (new Date() - startTime) / 1000;
                document.getElementById('timeSpent').textContent = `${timeSpent.toFixed(1)} sekuntia`;
                startTime = null;
                timerRunning = false;
            }
        }

        function resetTimer() {
            startTime = null;
            timerRunning = false;
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    </script>
</body>
</html>



<!-- <!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palapeli</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 20px;
        }

        #puzzleContainer {
            position: relative;
            width: 400px;
            height: 400px;
            border: 1px solid #333;
            overflow: visible;
        }

        .puzzlePiece {
            position: absolute;
            border: 1px solid #333;
            cursor: pointer;
        }

        #searchSection {
            margin-bottom: 20px;
        }

        #completedMessage {
            display: none;
            margin-top: 20px;
            font-size: 24px;
            color: green;
        }
    </style>
</head>

<body>
    <h1>Palapeli</h1>
    <div id="searchSection">
        <input type="text" id="searchQuery" placeholder="Anna hakusana" />
        <button onclick="searchImage()">Hae kuva</button>
    </div>
    <div id="puzzleContainer"></div>
    <div id="completedMessage">Palapeli on valmis! Aikasi oli <span id="timeSpent"></span>.</div>

    <script>
        let img = new Image();
        let selectedPiece = null;
        let offsetX, offsetY;
        let startTime = null;
        let timerRunning = false;

        // Kuva haetaan backendistä
        async function searchImage() {
            const query = document.getElementById('searchQuery').value.trim();
            if (query === '') {
                alert('Syötä hakusana');
                return;
            }

            try {
                const response = await fetch(`/searchImage?query=${encodeURIComponent(query)}`);
                const data = await response.json();

                if (data.imageUrl) {
                    img.src = data.imageUrl;
                    img.onload = function () {
                        createPuzzle(data.imageUrl);
                    };
                } else {
                    alert(data.error || 'Kuvaa ei löytynyt!');
                }
            } catch (error) {
                console.error('Virhe haettaessa kuvia:', error);
                alert('Virhe haettaessa kuvia.');
            }
        }

        // Hiiren painikkeen painamisen käsittely

        function onMouseDown(e) {
            // Ajastin käyntiin
            if (!timerRunning) {
                startTimer();
                timerRunning = true;
            }

            selectedPiece = e.target;
            offsetX = e.clientX - selectedPiece.getBoundingClientRect().left;
            offsetY = e.clientY - selectedPiece.getBoundingClientRect().top;
        }

        // Hiiren liikuttamisen käsittely
        function onMouseMove(e) {
            if (selectedPiece) {
                let newLeft = e.clientX - offsetX;
                let newTop = e.clientY - offsetY;
                const container = document.getElementById('puzzleContainer');
                const containerRect = container.getBoundingClientRect();
                const pieceWidth = selectedPiece.offsetWidth;
                const pieceHeight = selectedPiece.offsetHeight;

                // Palaset eivät voi poistua kontista, jotta ne eivät katoa (muuta myöhemmin niin, että palaset voi "laskea" kontin ulkopuolelle)
                if (newLeft < containerRect.left) newLeft = containerRect.left;
                if (newTop < containerRect.top) newTop = containerRect.top;
                if (newLeft + pieceWidth > containerRect.right) newLeft = containerRect.right - pieceWidth;
                if (newTop + pieceHeight > containerRect.bottom) newTop = containerRect.bottom - pieceHeight;

                selectedPiece.style.left = newLeft - containerRect.left + 'px';
                selectedPiece.style.top = newTop - containerRect.top + 'px';
            }
        }

        // Hiiren painikkeen vapautuksen käsittely
        function onMouseUp() {
            if (selectedPiece) {
                const targetLeft = parseFloat(selectedPiece.style.left);
                const targetTop = parseFloat(selectedPiece.style.top);
                const correctLeft = parseFloat(selectedPiece.dataset.correctLeft);
                const correctTop = parseFloat(selectedPiece.dataset.correctTop);

                // Tarkista, onko pala liikutettu merkittävästi
                const originalLeft = parseFloat(selectedPiece.dataset.originalLeft);
                const originalTop = parseFloat(selectedPiece.dataset.originalTop);
                const movedEnough = Math.abs(targetLeft - originalLeft) > 10 || Math.abs(targetTop - originalTop) > 10;

                // Palaset saavat vain lukittua oikeisiin paikkoihin
                if (movedEnough) {
                    // Onko pala oikeassa paikassa?
                    if (Math.abs(targetLeft - correctLeft) < 10 && Math.abs(targetTop - correctTop) < 10) {
                        // Siirrä pala oikeaan paikkaan
                        selectedPiece.style.left = correctLeft + 'px';
                        selectedPiece.style.top = correctTop + 'px';
                        selectedPiece.style.pointerEvents = 'none'; // Pala ei ole enää siirrettävissä
                    } else {
                        // Jos ei ole oikeassa paikassa, palaa alkuperäiseen sijaintiin
                        selectedPiece.style.left = originalLeft + 'px';
                        selectedPiece.style.top = originalTop + 'px';
                    }
                } else {
                    // Palaa alkuperäiseen sijaintiin, jos ei liikutettu tarpeeksi
                    selectedPiece.style.left = originalLeft + 'px';
                    selectedPiece.style.top = originalTop + 'px';
                }

                selectedPiece = null;

                // Onko peli valmis?
                checkIfPuzzleCompleted();
            }
        }

        function movePieceToRandomPosition(blockingPiece, allPieces) {
            const container = document.getElementById('puzzleContainer');
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;

            let randomLeft, randomTop;
            let isFree = false;

            // Etsii satunnaisen vapaan paikan
            while (!isFree) {
                randomLeft = Math.floor(Math.random() * (containerWidth - blockingPiece.offsetWidth));
                randomTop = Math.floor(Math.random() * (containerHeight - blockingPiece.offsetHeight));

                isFree = true;

                // Onko paikka jo käytössä?
                allPieces.forEach(piece => {
                    const pieceLeft = parseFloat(piece.style.left);
                    const pieceTop = parseFloat(piece.style.top);

                    if (Math.abs(pieceLeft - randomLeft) < blockingPiece.offsetWidth && Math.abs(pieceTop - randomTop) < blockingPiece.offsetHeight) {
                        isFree = false;
                    }
                });
            }

            // Siirtää väärän palan uuteen ruutuun ja nostaa sen z-indexiä
            blockingPiece.style.left = randomLeft + 'px';
            blockingPiece.style.top = randomTop + 'px';
            blockingPiece.style.zIndex = ++highestZIndex; // Nostaa väärän palan päällimmäiseksi
        }

        // Sekoitetaan palat
        function shufflePieces(pieces) {
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i].style.left, pieces[j].style.left] = [pieces[j].style.left, pieces[i].style.left];
                [pieces[i].style.top, pieces[j].style.top] = [pieces[j].style.top, pieces[i].style.top];
            }
        }

        // Palapelin luonti
        function createPuzzle(imageUrl) {
            const rows = 4;
            const cols = 4;
            const pieceMargin = 5;
            const puzzleContainer = document.getElementById('puzzleContainer');
            puzzleContainer.innerHTML = '';
            const pieceWidth = (img.width - (cols - 1) * pieceMargin) / cols;
            const pieceHeight = (img.height - (rows - 1) * pieceMargin) / rows;
            const pieces = [];

            // Kontti kuvan mittoihin
            puzzleContainer.style.width = img.width + 'px';
            puzzleContainer.style.height = img.height + 'px';

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const piece = document.createElement('div');
                    piece.className = 'puzzlePiece';
                    piece.style.width = pieceWidth + 'px';
                    piece.style.height = pieceHeight + 'px';
                    piece.style.backgroundImage = `url(${imageUrl})`;
                    piece.style.backgroundPosition = `-${col * (pieceWidth + pieceMargin)}px -${row * (pieceHeight + pieceMargin)}px`;

                    // Aseta palasten alkuperäinen sijainti satunnaisesti ruudukon ulkopuolelle
                    let randomX = Math.random() * (puzzleContainer.offsetWidth + 100) - 150; // 150px ruudukon vasemmalle ja oikealle
                    let randomY = Math.random() * (puzzleContainer.offsetHeight + 100) - 150; // 150px ruudukon ylös ja alas

                    // Estä palan sijoittaminen näkyviin ruudukon sisälle
                    if (randomX < 0) randomX = -pieceWidth; // Aseta vasemmalle
                    if (randomX > puzzleContainer.offsetWidth) randomX = puzzleContainer.offsetWidth; // Aseta oikealle
                    if (randomY < 0) randomY = -pieceHeight; // Aseta ylös
                    if (randomY > puzzleContainer.offsetHeight) randomY = puzzleContainer.offsetHeight; // Aseta alas

                    piece.style.left = randomX + 'px';
                    piece.style.top = randomY + 'px';

                    // Tallennetaan oikeat paikat
                    piece.dataset.correctLeft = (col * (pieceWidth + pieceMargin)).toString();
                    piece.dataset.correctTop = (row * (pieceHeight + pieceMargin)).toString();
                    piece.dataset.originalLeft = piece.style.left;
                    piece.dataset.originalTop = piece.style.top;

                    piece.addEventListener('mousedown', onMouseDown);
                    pieces.push(piece);
                    puzzleContainer.appendChild(piece);
                }
            }

            // Sekoitetaan palaset
            shufflePieces(pieces);

            // Nollataan ajastin ja näytetään viesti
            resetTimer();
            document.getElementById('completedMessage').style.display = 'none';
        }


        // Palapelin valmistumisen tsekkaus
        function checkIfPuzzleCompleted() {
            const pieces = document.querySelectorAll('.puzzlePiece');
            let isCompleted = true;

            // Tarkistetaan jokaisen palan sijainti
            pieces.forEach(piece => {
                const left = parseInt(piece.style.left);
                const top = parseInt(piece.style.top);
                const correctLeft = parseInt(piece.dataset.correctLeft);
                const correctTop = parseInt(piece.dataset.correctTop);

                if (left !== correctLeft || top !== correctTop) {
                    isCompleted = false;
                }
            });

            // Ajastimen pysäytys, jos kaikki palaset ovat oikeilla paikoillaan
            if (isCompleted) {
                stopTimer();
            }
        }

        // Ajastin käyntiin
        function startTimer() {
            startTime = new Date();
        }

        // Ajastin pois päältä (muunnos sekunneiksi)
        function stopTimer() {
            const endTime = new Date();
            const timeSpent = (endTime - startTime) / 1000;
            document.getElementById('timeSpent').innerText = `${timeSpent.toFixed(2)} sekuntia`;
            document.getElementById('completedMessage').style.display = 'block';
        }

        // Ajastimen resetointi
        function resetTimer() {
            startTime = null;
            timerRunning = false;
            document.getElementById('completedMessage').style.display = 'none'; // Piilota valmis-viesti
        }

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);

    </script>
</body>

</html> -->